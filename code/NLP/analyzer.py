import processing
import re
import nltk

class KeyChars(object):
	"""Contains attributes of key characteristics extracted from
	analyzing string objects."""

	def __init__(self, _originalData):
		self.originalData = _originalData
		# all will contain: [(characteristic, distance), ...]
		self.flyer_name = []  # week_page
		self.product_name = []  # from product inventory
		self.unit_promo_price = []  # price per unit
		self.uom = []  # unit of measurement
		self.least_unit_for_promo = [(1, 10000)]  # minimum quantity before promotion applies
		self.save_per_unit = []  # savings per unit
		self.discount = []  # discount from original price
		self.organic = [(0, 10000)]  # boolean indicating organic (1) or not organic (0)

	def accessMetric(self, sample):
		"""ONLY USED BY MAX/MIN/SORTING FUNCTIONS"""
		return sample[1]

class NLPAnalyzer(object):
	"""Take in blocks (tuples) generated by OCR processing and analyzes
	them for key characteristics."""

	def __init__(self, _productInventory, _metricInventory):
		self.productInventory = _productInventory
		self.metricInventory = _metricInventory
		self.store = []  # stores a list of KeyChars for the most recent analyze call

	def analyze(self, block):
		"""Analyzes a block and generates key characteristics from
		each stringObject (dict) within."""
		if not isinstance(block, tuple):
			raise TypeError("segment should be of type tuple")

		found = {"flyer_name": False, "product_name": False, "unit_promo_price": False,
						"uom": False, "least_unit_for_promo": False, "save_per_unit": False,
						"discount": False, "organic": False}
		# check dict 1


		# check dict 2


		# check dict 3


		# check dict 4


		# check dict 5




		# # loop through the block and generate KeyChars for each segment
		# for segment in block:
		# 	# stores information
		# 	keyChars = KeyChars(segment)

		# 	# extract phrase from segment in lower case
		# 	phrase = segment["text"].lower()

		# 	# check the phrase for information
		# 	self.checkProductName(phrase, keyChars)
		# 	self.checkUOM(phrase, keyChars)

		# 	# append the keyChar into store
		# 	self.store.append(keyChars)
		# 	print(keyChars.uom, keyChars.product_name)

		# ensuring to update each keyChar member to an appropriate value
		results = {"flyer_name": None, "product_name": None, "unit_promo_price": None,
						"uom": None, "least_unit_for_promo": 1, "save_per_unit": None,
						"discount": None, "organic": 0}

		# compares with stored ratios
		optimizations = {"flyer_name": 10000, "product_name": 0, "unit_promo_price": 10000,
						"uom": None, "least_unit_for_promo": 1, "save_per_unit": None,
						"discount": None, "organic": 0}
		# perform voting on the most likely characteristics
		for i in range(len(self.store)):

			pass


		# reset to an empty list
		self.store.clear()
		return results

	def checkFlyerName(self, phrase, keyChars):
		"""Check the phrase for flyer name"""
		pass

	# stores keyChar with Levenshtein similarity ratio
	def checkProductName(self, phrase, keyChars):
		"""Check the phrase for product name"""
		# iterate through item and check for comparison
		for i in range(self.productInventory["product_name"].count()):
			if re.search(self.productInventory["product_name"][i], phrase) is not None:
				# calculate levenshtein edit-distance
				distance = nltk.edit_distance(self.productInventory["product_name"][i], phrase)
				ratio = 1 - distance/(len(self.productInventory["product_name"][i]) + len(phrase))
				keyChars.product_name.append((self.productInventory["product_name"][i], ratio))
		keyChars.product_name = max(keyChars.product_name, default=None, key=keyChars.accessMetric)

	def checkUOM(self, phrase, keyChars):
		"""Check the phrase for unit of measurement"""
		# list of strings split at each slash, remove the first string since it wont be uom
		slashSplit = re.split("\/", phrase)[1:]
		# loop through each split and compare to uom
		for subString in slashSplit:
			for i in range(self.metricInventory["units"].count()):
				frequency = subString.count(self.metricInventory["units"][i])
				# only append
				if frequency > 0:
					keyChars.uom.append((self.metricInventory["units"][i], frequency))

if __name__ == "__main__":
	analyzer = NLPAnalyzer(processing.generateProductInventory(), processing.generateUnitsInventory())
	tp = ({"text": "Leg Quarters $5/lb"}, {"text": "Whole Chicken Leg Quarters $0.1/g"})
	analyzer.analyze(tp)
	pass
