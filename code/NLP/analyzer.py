import processing
import re
import nltk


# hierarchy from 1-5 (left to right)
BIAS = [1, 0.9, 0.8, 0.7, 0.6]


class KeyChars(object):
	"""Contains attributes of key characteristics extracted from
	analyzing string objects."""

	def __init__(self, _dictHeirachy):
		self.dictHeirachy = _dictHeirachy
		# all will contain: [(characteristic, distance), ...]
		self.flyer_name = []  # week_page
		self.product_name = []  # from product inventory
		self.unit_promo_price = []  # price per unit
		self.uom = []  # unit of measurement
		self.least_unit_for_promo = []  # minimum quantity before promotion applies, def=1
		self.save_per_unit = []  # savings per unit
		self.discount = []  # discount from original price
		self.organic = []  # boolean indicating organic (1) or not organic (0), def=0

	def getMetric(self, sample):
		"""ONLY USED BY MAX/MIN/SORTING FUNCTIONS"""
		return sample[1]

	@staticmethod
	def getHeirachy(keyChar):
		return keyChar.dictHeirachy



class NLPAnalyzer(object):
	"""Take in blocks (tuples) generated by OCR processing and analyzes
	them for key characteristics."""

	def __init__(self, _productInventory, _metricInventory, _discountInventory):
		self.productInventory = _productInventory
		self.metricInventory = _metricInventory
		self.discountInventory = _discountInventory
		self.store = []  # stores a list of KeyChars for the most recent analyze call

	def analyze(self, block):
		"""Analyzes a block and generates key characteristics from
		each stringObject (dict) within."""
		if not isinstance(block, tuple):
			raise TypeError("segment should be of type tuple")

		found = {"flyer_name": False, "product_name": False, "unit_promo_price": False,
						"uom": False, "least_unit_for_promo": False, "save_per_unit": False,
						"discount": False, "organic": False}

		# loop through the block of 5 dicts
		for segment in block:
			# stores heirachy
			keyChars = KeyChars(int(segment["type"]))
			# extract phrase from segment in lower case
			phrase = segment["text"].lower()
			if phrase == "":
				continue
			# check the phrase for information
			self.checkProductName(phrase, keyChars)

			# store the keyChar instant
			self.store.append(keyChars)
			print(keyChars.product_name)

		# sort store in order of dict heirachy from 1 (index 0) to 5 (index 4)
		self.store = sorted(self.store, key=KeyChars.getHeirachy)
		results = KeyChars(0)

		results.product_name = self.voteProductName()


		# reset to an empty list
		self.store.clear()
		return results

	def checkFlyerName(self, phrase, keyChars):
		"""Check the phrase for flyer name"""
		pass

	# stores keyChar with Levenshtein similarity ratio
	def checkProductName(self, phrase, keyChars):
		"""Check the phrase for product name"""
		# 1st one never contains the product name
		if keyChars.dictHeirachy == 1:
			return
		# iterate through item and check for comparison
		for i in range(self.productInventory["product_name"].count()):
			# search for product name in phrase
			if re.search(self.productInventory["product_name"][i], phrase) is not None:
				# calculate levenshtein edit-distance
				distance = nltk.edit_distance(self.productInventory["product_name"][i], phrase)
				ratio = 1 - distance/(len(self.productInventory["product_name"][i]) + len(phrase))
				keyChars.product_name.append((self.productInventory["product_name"][i], ratio))
		# pick the most likely product when many phrases match the same
		if keyChars.product_name is not None:
			keyChars.product_name = max(keyChars.product_name, default=None, key=keyChars.getMetric)



	def checkUPP(self, phrase, keyChars):
		"""Check the phrase for unit promo price"""
		# check for dollar
		key = "\$"
		currSplit = re.split(key, phrase)
		# rule out any price from phrase, and focus on percentage tagging
		if len(currSplit) == 1:
			key = "\%"
			currSplit = re.split(key, phrase)


	def checkUOM(self, phrase, keyChars):
		"""Check the phrase for unit of measurement"""
		# list of strings split at each slash, remove the first string since it wont be uom
		slashSplit = re.split("\/", phrase)[1:]
		# loop through each split and compare to uom
		for subString in slashSplit:
			for i in range(self.metricInventory["units"].count()):
				frequency = subString.count(self.metricInventory["units"][i])
				# only append
				if frequency > 0:
					keyChars.uom.append((self.metricInventory["units"][i], frequency))


	def voteProductName(self):
		"""Vote for product name:
			Order of bias in dictHeirachy: 3, 2, 4, 5, 1"""
		# best
		bestResult = None
		bestRatio = 0
		current = 0
		for i in range(0, len(self.store), 1):
			if not self.store[i].product_name:
				continue
			current = self.store[i].product_name[1]
			currentHeirachy = self.store[i].dictHeirachy
			if currentHeirachy == 1:
				current *= BIAS[4]  # rank = 5, -1 for index
			elif currentHeirachy == 2:
				current *= BIAS[1]
			elif currentHeirachy == 3:
				current *= BIAS[0]
			elif currentHeirachy == 4:
				current *= BIAS[2]
			elif currentHeirachy == 5:
				current *= BIAS[3]
			if current > bestRatio:
				best = current
				bestResult = self.store[i].product_name[0]
		return bestResult



if __name__ == "__main__":
	analyzer = NLPAnalyzer(processing.generateProductInventory(),
									processing.generateUnitsInventory(),
									processing.generateDiscountInventory())
	tp = ({"text": "Whole Chicken Leg Quarters ", "type": 3},
			{"text": "Leg Quarters $5/lb", "type": 1},
			{"text": "Whole Chicken Leg", "type": 2},
			{"text": "BananaMan $45.00", "type": 4})
	results = analyzer.analyze(tp)
	print(results.product_name)
	pass
