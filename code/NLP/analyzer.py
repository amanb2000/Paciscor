import processing
import re
import nltk
import json


# hierarchy from 1-5 (left to right)
BIAS = [1, 0.9, 0.8, 0.7, 0.6]


class Product(object):
	"""Contains attributes of key characteristics extracted from
	analyzing string objects."""

	def __init__(self, _dictHeirarchy):
		self.dictHeirarchy = _dictHeirarchy
		self.payPrice = 0
		self.savePrice = 0
		# all will contain: [(characteristic, distance), ...]
		self.flyer_name = 'No_name'  # week_page
		self.product_name = ''  # from product inventory
		self.unit_promo_price = None  # price per unit
		self.uom = None  # unit of measurement
		self.least_unit_for_promo = 1  # minimum quantity before promotion applies, def=1
		self.save_per_unit = None  # savings per unit
		self.discount = 0  # discount from original price
		self.organic = 0 # boolean indicating organic (1) or not organic (0), def=0

	def generate_unit_promo_price(self):
		"""requires the price and the least number of units for promo"""
		if not isinstance(self.payPrice, float):
			return
		self.unit_promo_price = round(self.payPrice/self.least_unit_for_promo, 2)


	def generate_save_per_unit(self):
		"""requires save-price and learn number of units for promo"""
		if not isinstance(self.savePrice, float):
			return
		self.save_per_unit = round(self.savePrice/self.least_unit_for_promo, 2)

	def generate_discount(self):
		"""requires save per unit and unit promo prices"""
		if not isinstance(self.unit_promo_price, float) or not isinstance(self.save_per_unit, float):
			return
		self.discount = self.save_per_unit/self.unit_promo_price

	def generate_data(self):
		"""Generates:

			- unit promo price
			- save per unit
			- discount in decimal (0 to 1)"""
		self.generate_unit_promo_price()
		self.generate_save_per_unit()
		self.discount()


	def get_metric(self, sample):
		"""ONLY USED BY MAX/MIN/SORTING FUNCTIONS"""
		return sample[1]

	@staticmethod
	def get_heirarchy(keyChar):
		"""ONLY USED BY MAX/MIN/SORTING FUNCTIONS"""
		return keyChar.dictHeirarchy



class NLP_Analyzer(object):
	"""Take in blocks (tuples) generated by OCR processing and analyzes
	them for key characteristics."""

	def __init__(self, _productInventory, _metricInventory, _discountInventory):
		self.productInventory = _productInventory
		self.metricInventory = _metricInventory
		self.discountInventory = _discountInventory
		self.store = []  # stores a list of Product for the most recent analyze call

		# Create units string for regex
		self.UNITS_STR = ''
		for index, row in self.metricInventory.iterrows(): # If this stops working, ask Aman to fix it on your computer.
			self.UNITS_STR += row['units'] + '|'
		self.UNITS_STR = self.UNITS_STR[:-1]

	def analyze(self, block):
		"""Analyzes a block and generates key characteristics from
		each stringObject (dict) within."""
		if not isinstance(block, tuple):
			raise TypeError("segment should be of type tuple")

		# found = {"flyer_name": False, "product_name": False, "unit_promo_price": False,
		# 				"uom": False, "least_unit_for_promo": False, "save_per_unit": False,
		# 				"discount": False, "organic": False}

		# loop through the block of 5 dicts
		for segment in block:
			# stores heirachy
			keyChars = Product(int(segment["type"]))
			# extract phrase from segment in lower case
			phrase = segment["text"].lower()
			if phrase == "":
				continue
			# check the phrase for information
			# self.check_deal(phrase, keyChars)
			self.check_product_name(phrase, keyChars)  # product name
			self.check_organic(phrase, keyChars)  # organic

			# store the keyChar instant
			self.store.append(keyChars)

		# Determine price data
		self.find_price_data(block)

		# sort store in order of dict heirachy from 1 (index 0) to 5 (index 4)
		self.store = sorted(self.store, key=Product.get_heirarchy)
		results = Product(0)

		results.product_name = self.vote_product_name()
		results.organic = self.vote_organic()


		# reset to an empty list
		self.store.clear()
		return results

	def check_flyer_name(self, phrase, keyChars):
		"""Check the phrase for flyer name"""
		return

	# stores keyChar with Levenshtein similarity ratio
	def check_product_name(self, phrase, keyChars):
		"""Check the phrase for product name"""
		# 1st one never contains the product name
		if keyChars.dictHeirarchy == 1:
			return
		keyChars.product_name = []
		# iterate through item and check for comparison
		for i in range(self.productInventory["product_name"].count()):
			# search for product name in phrase
			if re.search(self.productInventory["product_name"][i], phrase) is not None:
				# calculate levenshtein edit-distance
				distance = nltk.edit_distance(self.productInventory["product_name"][i], phrase)
				ratio = 1 - distance/(len(self.productInventory["product_name"][i]) + len(phrase))
				keyChars.product_name.append((self.productInventory["product_name"][i], ratio))
		# pick the most likely product when many phrases match the same
		if keyChars.product_name is not None:
			keyChars.product_name = max(keyChars.product_name, default=None, key=keyChars.get_metric)
		return

	def find_price_data(self, content):
		others = []
		driving = None
		for seg in content:
			# Correct characters!
			src = re.sub('°', '¢', seg['text'])
			# Begin
			nums = re.findall('[^ &^\n]*[0-9.]+[^ &^\n]*', src)
			valuables = []
			for inst in nums:
				# Filter instances (special rules)
				if len(re.findall('[-]', inst)) > 0:
					continue
				# Prep for adding modifiers
				data = inst
				# Run before check
				while True:
					new_data = re.findall('(?:save|\$|on)[ |\n]*{}+'.format(data), src, re.IGNORECASE)
					if new_data is None or len(new_data) < 1:
						break
					else:
						if isinstance(new_data[0], tuple):
							data = new_data[0][0]
						else:
							data = new_data[0]
				# Run after check
				print('{}'.format(self.UNITS_STR))
				while True:
					new_data = re.findall('{}[ |\n]*(?:off|¢|/|{})'.format(data, self.UNITS_STR), src, re.IGNORECASE)
					if new_data is None or len(new_data) < 1:
						break
					else:
						if isinstance(new_data[0], tuple):
							data = new_data[0][0]
						else:
							data = new_data[0]
				if seg['type'] == 1:
					# Make this driving
					driving = data # Assume only one is best seg
				else:
					others += [data]
		# Evaluate data
		# Begin with driving
		if driving is not None:
			unit = re.findall('{}'.format(self.UNITS_STR), driving)
			vals = re.findall('[^ &^\n]*[0-9]+[^ &^\n]*', driving)
			val = int(vals[0]) if len(vals) < 2 else int(vals[1]) # Misses cases where we have 2/$7
			self.payPrice = val/100
			if unit is not None and len(unit) > 0:
				self.uom = unit[0]
			elif len(vals) > 1:
				self.uom = 'units'
		# Compute others
		for i in others:
			unit = re.findall('{}'.format(self.UNITS_STR), i)
			if unit is not None and len(unit) > 0 and self.uom is not None:
				self.uom = i
			# Check deal
			deal = re.findall('save', i, re.IGNORECASE)
			if deal is not None and len(deal) > 0 and self.save_per_unit is None:
				val = re.findall('[^ &^\n]*[0-9]+[^ &^\n]*', i)
				savings = float(val[0]) if len(val) < 2 else float(val[0])/100
				for i in others:
					onT = re.findall('on', i, re.IGNORECASE)
					if onT is not None and len(onT) > 0:
						num = int(re.findall('[0-9]', i)[0])
						self.save_per_unit = savings / num
				if self.save_per_unit is None:
					self.save_per_unit = savings
		return

	def check_deal(self, phrase, keyChars):
		"""Check the phrase for deals, costs, etc:

			Price
				- $
					- do cents later
				- "/"
					- UOM
					- Least quantity of product

			Discount
				- % (percentage)
					- "OFF"
					- Value from 0-100
					- UOM
				- "SAVE"
					- "UP TO"
						- Savings Amount (Price)
					- Savings Amount (Price)
		"""
		costFound = False
		discountFound = False
		quantityFound = False
		checkPercent  = False
		unitsFound = False

		# determine if discount/saving
		offTag = re.search("off", phrase)
		saveTag = re.search("save", phrase)
		if offTag is not None or saveTag is not None:
			discountFound = True
		# extract a dollar amount
		# re.split splits a string into a list with elements seperated at the key
		keyPos = re.search("\$", phrase)
		# no dollar sign exists
		if keyPos is None:
			# try cents
			keySplit = re.search("\u00a2", phrase)
			# no cents amount in phrase
			if keySplit is None:
				checkPercent = True
			else:
				# extract the cent value from last two numbers
				centValue = int(phrase[keySplit.start() - 2: keySplit.start()])/100
				if saveTag is not None:
					pass
		else:
			costFound = True
		# determine cost or check for percentage
		if costFound:
			costSplit = re.split(key, phrase)
			# check for forward slash
			for e in costSplit:
				fSlash = re.search("\/", e)
				if fSlash is not None:
					# quantity
					if fSlash.end() == len(e):
						pass
					# assume uom
					else:
						pass
				else:
					pass
		return

	def check_uom(self, phrase, keyChars):
		"""Check the phrase for unit of measurement"""
		# list of strings split at each slash, remove the first string since it wont be uom
		slashSplit = re.split("\/", phrase)[1:]
		# loop through each split and compare to uom
		for subString in slashSplit:
			for i in range(self.metricInventory["units"].count()):
				frequency = subString.count(self.metricInventory["units"][i])
				# only append
				if frequency > 0:
					keyChars.uom.append((self.metricInventory["units"][i], frequency))
		return

	def check_organic(self, phrase, keyChars):
		key = "organic"
		if re.search(key, phrase) is not None:
			keyChars.organic = 1
		return

	def vote_product_name(self):
		"""Vote for product name:
			Order of bias in dictHeirarchy: 3, 2, 4, 5, 1"""
		# best
		bestResult = None
		bestRatio = 0
		current = 0
		for levelChars in self.store:
			if not levelChars.product_name:
				continue
			current = levelChars.product_name[1]
			currentHeirachy = levelChars.dictHeirarchy
			if currentHeirachy == 1:
				current *= BIAS[4]  # rank = 5, -1 for index
			elif currentHeirachy == 2:
				current *= BIAS[1]
			elif currentHeirachy == 3:
				current *= BIAS[0]
			elif currentHeirachy == 4:
				current *= BIAS[2]
			elif currentHeirachy == 5:
				current *= BIAS[3]
			if current > bestRatio:
				best = current
				bestResult = levelChars.product_name[0]
		return bestResult

	def vote_organic(self):
		for levelChars in self.store:
			if levelChars.organic > 0:
				return 1
		return 0


if __name__ == "__main__":
	analyzer = NLP_Analyzer(processing.generateProductInventory(),
									processing.generateUnitsInventory(),
									processing.generateDiscountInventory())
	tp = json.load(open('code/NLP/sample_OCR_output_2.json'))
	results = analyzer.analyze(tuple(tp))
	# print(results.payPrice)
	pass
