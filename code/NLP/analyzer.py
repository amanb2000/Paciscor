import processing
import re
import nltk


# hierarchy from 1-5 (left to right)
BIAS = [1, 0.9, 0.8, 0.7, 0.6]


class KeyChars(object):
	"""Contains attributes of key characteristics extracted from
	analyzing string objects."""

	def __init__(self, _dictHeirachy):
		self.dictHeirachy = _dictHeirachy
		# all will contain: [(characteristic, distance), ...]
		self.flyer_name = []  # week_page
		self.product_name = []  # from product inventory
		self.unit_promo_price = []  # price per unit
		self.uom = []  # unit of measurement
		self.least_unit_for_promo = []  # minimum quantity before promotion applies, def=1
		self.save_per_unit = []  # savings per unit
		self.discount = []  # discount from original price
		self.organic = 0 # boolean indicating organic (1) or not organic (0), def=0

	def getMetric(self, sample):
		"""ONLY USED BY MAX/MIN/SORTING FUNCTIONS"""
		return sample[1]

	@staticmethod
	def getHeirachy(keyChar):
		"""ONLY USED BY MAX/MIN/SORTING FUNCTIONS"""
		return keyChar.dictHeirachy



class NLPAnalyzer(object):
	"""Take in blocks (tuples) generated by OCR processing and analyzes
	them for key characteristics."""

	def __init__(self, _productInventory, _metricInventory, _discountInventory):
		self.productInventory = _productInventory
		self.metricInventory = _metricInventory
		self.discountInventory = _discountInventory
		self.store = []  # stores a list of KeyChars for the most recent analyze call

	def analyze(self, block):
		"""Analyzes a block and generates key characteristics from
		each stringObject (dict) within."""
		if not isinstance(block, tuple):
			raise TypeError("segment should be of type tuple")

		# found = {"flyer_name": False, "product_name": False, "unit_promo_price": False,
		# 				"uom": False, "least_unit_for_promo": False, "save_per_unit": False,
		# 				"discount": False, "organic": False}

		# loop through the block of 5 dicts
		for segment in block:
			# stores heirachy
			keyChars = KeyChars(int(segment["type"]))
			# extract phrase from segment in lower case
			phrase = segment["text"].lower()
			if phrase == "":
				continue
			# check the phrase for information
			self.checkDeal(phrase, keyChars)
			self.checkProductName(phrase, keyChars)  # product name
			self.checkOrganic(phrase, keyChars)  # organic

			# store the keyChar instant
			self.store.append(keyChars)

		# sort store in order of dict heirachy from 1 (index 0) to 5 (index 4)
		self.store = sorted(self.store, key=KeyChars.getHeirachy)
		results = KeyChars(0)

		results.product_name = self.voteProductName()
		results.organic = self.voteOrganic()


		# reset to an empty list
		self.store.clear()
		return results

	def checkFlyerName(self, phrase, keyChars):
		"""Check the phrase for flyer name"""
		return

	# stores keyChar with Levenshtein similarity ratio
	def checkProductName(self, phrase, keyChars):
		"""Check the phrase for product name"""
		# 1st one never contains the product name
		if keyChars.dictHeirachy == 1:
			return
		# iterate through item and check for comparison
		for i in range(self.productInventory["product_name"].count()):
			# search for product name in phrase
			if re.search(self.productInventory["product_name"][i], phrase) is not None:
				# calculate levenshtein edit-distance
				distance = nltk.edit_distance(self.productInventory["product_name"][i], phrase)
				ratio = 1 - distance/(len(self.productInventory["product_name"][i]) + len(phrase))
				keyChars.product_name.append((self.productInventory["product_name"][i], ratio))
		# pick the most likely product when many phrases match the same
		if keyChars.product_name is not None:
			keyChars.product_name = max(keyChars.product_name, default=None, key=keyChars.getMetric)
		return



	def checkDeal(self, phrase, keyChars):
		"""Check the phrase for deals, costs, etc:

			Price
				- $
					- do cents later
				- "/"
					- UOM
					- Least quantity of product

			Discount
				- % (percentage)
					- "OFF"
					- Value from 0-100
					- UOM
				- "SAVE"
					- "UP TO"
						- Savings Amount (Price)
					- Savings Amount (Price)
		"""
		costFound = False
		discountFound = False
		quantityFound = False
		checkPercent  = False
		unitsFound = False

		# determine if discount/saving
		offTag = re.search("off", phrase)
		saveTag = re.search("save", phrase)
		if offTag is not None or saveTag is not None:
			discountFound = True
		# extract a dollar amount
		# re.split splits a string into a list with elements seperated at the key
		keyPos = re.search("\$", phrase)
		# no dollar sign exists
		if keyPos is None:
			# try cents
			keySplit = re.search("\u00a2", phrase)
			# no cents amount in phrase
			if keySplit is None:
				checkPercent = True
			else:
				# extract the cent value from last two numbers
				centValue = int(phrase[keySplit.start() - 2: keySplit.start()])/100
				if saveTag is not None:


		else:
			costFound = True
		# determine cost or check for percentage
		if costFound:
			costSplit = re.split(key, phrase)
			# check for forward slash
			for e in costSplit:
				fSlash = re.search("\/", e)
				if fSlash is not None:
					# quantity
					if fSlash.end() == len(e):
						pass
					# assume uom
					else:
						pass
				else:

		return

	def checkUOM(self, phrase, keyChars):
		"""Check the phrase for unit of measurement"""
		# list of strings split at each slash, remove the first string since it wont be uom
		slashSplit = re.split("\/", phrase)[1:]
		# loop through each split and compare to uom
		for subString in slashSplit:
			for i in range(self.metricInventory["units"].count()):
				frequency = subString.count(self.metricInventory["units"][i])
				# only append
				if frequency > 0:
					keyChars.uom.append((self.metricInventory["units"][i], frequency))
		return

	def checkOrganic(self, phrase, keyChars):
		key = "organic"
		if re.search(key, phrase) is not None:
			keyChars.organic = 1
		return

	def voteProductName(self):
		"""Vote for product name:
			Order of bias in dictHeirachy: 3, 2, 4, 5, 1"""
		# best
		bestResult = None
		bestRatio = 0
		current = 0
		for levelChars in self.store:
			if not levelChars.product_name:
				continue
			current = levelChars.product_name[1]
			currentHeirachy = levelChars.dictHeirachy
			if currentHeirachy == 1:
				current *= BIAS[4]  # rank = 5, -1 for index
			elif currentHeirachy == 2:
				current *= BIAS[1]
			elif currentHeirachy == 3:
				current *= BIAS[0]
			elif currentHeirachy == 4:
				current *= BIAS[2]
			elif currentHeirachy == 5:
				current *= BIAS[3]
			if current > bestRatio:
				best = current
				bestResult = levelChars.product_name[0]
		return bestResult

	def voteOrganic(self):
		for levelChars in self.store:
			if levelChars.organic > 0:
				return 1
		return 0


if __name__ == "__main__":
	analyzer = NLPAnalyzer(processing.generateProductInventory(),
									processing.generateUnitsInventory(),
									processing.generateDiscountInventory())
	tp = ({"text": "Whole Chicken Leg Quarters ", "type": 3},
			{"text": "$3.00/lb", "type": 1},
			{"text": "Now dont miss your chance to SAVE $3.54/lb", "type": 2},
			{"text": "Drink a pancake smoothie with orange lemonade and ostrich juice", "type": 4})
	results = analyzer.analyze(tp)
	print(results.product_name, results.organic)
	pass
